设计原则
    1.单一职责原则SRP(Single Responsibilities Principle)
        功能要单一
        实现高内聚、低耦合的指导方针
        Case:
            数据库链接
    2.开放-封闭原则OCP(Open-Close Principle)
        对于扩展是开放的
        对于修改是封闭的
        Case:
            将经常变化的类&不经常变化的类隔离开来
    3.依赖倒转原则DIP(Dependence Inversion Principle)
        高层模块不应该依赖低层模块，两者都应该依赖其抽象；
        抽象不应该依赖细节；
        细节应该依赖抽象
    4.接口隔离原则
        假设变化不会发生，当变化发生时，我们就创建抽象(比如抽象类，接口等等)来隔离以后发生的同类变化
    5.里氏替换原则
        一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别
设计模式
    1.创建型模式
        1.工厂模式
            意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
            主要解决：主要解决接口选择的问题。
            何时使用：我们明确地计划不同条件下创建不同实例时。
            如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
            关键代码：创建过程在其子类执
        2.单例模式
            意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
            主要解决：一个全局使用的类频繁地创建与销毁。
            何时使用：当您想控制实例数目，节省系统资源的时候。
            如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
            关键代码：构造函数是私有的。
        3.适配器模式
            意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
            主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
            何时使用：1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）
            如何解决：继承或依赖（推荐）。
            关键代码：适配器继承或依赖已有的对象，实现想要的目标接口
        4.装饰器模式
            意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
            主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
            何时使用：在不想增加很多子类的情况下扩展类。
            如何解决：将具体功能职责划分，同时继承装饰者模式。
            关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。
        5.代理模式
            意图：为其他对象提供一种代理以控制对这个对象的访问。
            主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
            何时使用：想在访问一个类时做一些控制。
            如何解决：增加中间层。
            关键代码：实现与被代理类组合。
        6.外观模式
            意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
            主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
            何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。
            如何解决：客户端不与系统耦合，外观类与系统耦合。
            关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
        7.观察者模式
            意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
            主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。
            何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。
            如何解决：使用面向对象技术，可以将这种依赖关系弱化。
            关键代码：在抽象类里有一个 ArrayList 存放观察者们。
        8.迭代器模式
            意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
            主要解决：不同的方式来遍历整个整合对象。
            何时使用：遍历一个聚合对象。
            如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。
            关键代码：定义接口：hasNext, next。
        9.状态模式
            意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
            主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。
            何时使用：代码中包含大量与对象状态有关的条件语句。
            如何解决：将各种具体的状态类抽象出来。
            关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。





